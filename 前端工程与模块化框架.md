### 前端工程与模块化框架

糖饼 在 div.io 的一篇文章 [《再谈 SeaJS 与 RequireJS 的差异》](http://div.io/topic/430)觉得可以借着这篇继续谈一下，加上最近spm3发布，在seajs的官网上又引来了一场 口水战 ，我并不想参与到这场论战中，各有所爱的事情不好评论什么，但我想从工程的角度来阐述一下已知的模块化框架相关的问题，并给出一些新的思路，~~其实也不新啦，都实践了2多年了~~

```
前端模块化框架肩负着 模块管理、资源加载 两项重要的功能，这两项功能与工具、性能、业务、部署等工程环节都有着非常紧密的联系。因此，模块化框架的设计应该最高优先级考虑工程需要。

```

 先看看 @糖饼 的文章 《再谈 SeaJS 与 RequireJS 的差异》：
 
  谁更有能成为未来的异步模块标准？SeaJS 遵循 CMD 规范，RequireJS 遵循 AMD 规范，先从这两种不同的格式说起。
  
  #### CMD
  
  #### CMD 模块依赖声明方式：
 ```
  define(function (require) {
    var a = require('./a');
    var b = require('./b');
    // more code ..
})
 ```
  CMD 依赖是就近声明，通过内部require方法进行声明。但是因为是异步模块，加载器需要提前加载这些模块，所以模块真正使用前需要提取模块里面所有的依赖。无论是加载器即时提取，还是通过自动化工具预先提取，CMD 的这种依赖声明格式只能通过静态分析方式实现，这也正是 CMD 的弊端所在。
  
  ### CMD 规范的弊端
  
  1,不能直接压缩：require是局部变量，意味着不能直接的通过压缩工具进行压缩，若require这个变量被替换，加载器与自动化工具将无法获取模块的依赖。
  
  2,模块书写有额外约定：路径参数不能进行字符串运算，不能使用变量代替，否则加载器与自动化工具无法正确提取路径。
  
  规范之外的约定意味着更多的文档说明，除非它们也是规范中的一部分。
  
  注：SeaJS 静态分析实现是把模块包toString()后使用正则提取require部分得到依赖的模块路径。
  
 #### AMD
 
  #### AMD 模块依赖声明方式：
  
  ```
  define(['./a', './b'], function (a, b) {
    // more code ..
 })
  ```
  AMD 的依赖是提前声明。这种优势的好处就是依赖无需通过静态分析，无论是加载器还是自动化工具都可以很直接的获取到依赖，规范的定义可以更简单，意味着可能产生更强大的实现，这对加载器与自动化分析工具都是有利的。
  
  #### AMD 规范的弊端

 1,依赖提前声明在代码书写上不是那么友好
 
 2,模块内部与 NodeJS 的 Modules 有一定的差异
 
 
 关于第二点的问题需要特别说明下。其实无论是 CMD 还是 AMD 的异步模块，都无法与同步模块规范保持一致（NodeJS 的 Modules），只有谁比谁更像同步模块而已。AMD 要转换为同步模块，除了去掉define函数的包裹外，需要在头部使用require把依赖声明好，而 CMD 只需要去掉define函数的包裹即可。
 
 ### 总结


从规范上来说，AMD 更加简单且严谨，适用性更广，而在 RequireJS 强力的推动下，在国外几乎成了事实上的异步模块标准，各大类库也相继支持 AMD 规范。

但从 SeaJS 与 CMD 来说，也做了很多不错东西：1、相对自然的依赖声明风格 2、小而美的内部实现 3、贴心的外围功能设计 4、更好的中文社区支持

如果有可能，我希望看到 SeaJS 也支持 AMD，与前端社区大环境保持一致最终幸福的是广大开发者。


